%% -*- tab-width: 4;erlang-indent-level: 4;indent-tabs-mode: nil -*-
%% ex: ts=4 sw=4 et
%% ----------------------------------------------------------------------------
%%
%% Copyright (c) 2008-2011 Tim Watson (watson.timothy@gmail.com)
%%
%% Permission is hereby granted, free of charge, to any person obtaining a copy
%% of this software and associated documentation files (the "Software"), deal
%% in the Software without restriction, including without limitation the rights
%% to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
%% copies of the Software, and to permit persons to whom the Software is
%% furnished to do so, subject to the following conditions:
%%
%% The above copyright notice and this permission notice shall be included in
%% all copies or substantial portions of the Software.
%%
%% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
%% IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
%% FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
%% AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
%% LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
%% FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
%% IN THE SOFTWARE.
%% ----------------------------------------------------------------------------
-module(instrumented).

-compile(export_all).

%% this function is called by the instrumented block
if_prefix(Events, Prefix) ->
    lists:prefix(Prefix, atom_to_list(hd(Events))).

handle_events(Events) ->
    %% @instrumented [cond_throw_signal 'sig.continue'
    %%                      [eval_p instrumented if_prefix ["node1@"]]]
    {received, Events}.

test() ->
    SUT = spawn_test(),
    SUT ! {events, ['a@foo', 'b@bar', 'c@baz']},
    annotations:instrument(?MODULE),
    %% these should slip past the cond_wait and not hit the throw
    SUT ! {events, [{a, 1}, {b, 1}, {c, 1}]},
    %% but these will not...
    SUT ! {events, ['node1@foobarbaz', 'node2@bonkers']},
    true = erlang:is_process_alive(SUT),
    SUT ! {stop, self()},
    receive
        {stopped, Captured} ->
            io:format("~p~n", [Captured]);
        Other ->
            throw(Other)
    end,
    ok.

spawn_test() ->
    spawn(fun() ->
            process_flag(trap_exit, true),
            loop([])
          end).

loop(Acc) ->
    receive
        {events, Events} ->
            [catch(handle_events(Events))|Acc];
        {stop, Sender} ->
            Sender ! {stopped, Acc}
    end.

